<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ispc` crate."><meta name="keywords" content="rust, rustlang, rust-lang, ispc"><title>ispc - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate ispc</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all ispc's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'ispc', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/ispc/lib.rs.html#1-214' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>ispc</a></span></h1><div class='docblock'><h1 id="ispc-rs" class="section-header"><a href="#ispc-rs">ispc-rs</a></h1>
<p>A small library meant to be used as a build dependency with Cargo for easily
integrating <a href="https://ispc.github.io/">ISPC</a> code into Rust projects.</p>
<p><a href="https://crates.io/crates/ispc"><img src="https://img.shields.io/crates/v/ispc.svg" alt="Crates.io" /></a>
<a href="https://travis-ci.org/Twinklebear/ispc-rs"><img src="https://travis-ci.org/Twinklebear/ispc-rs.svg?branch=master" alt="Build Status" /></a></p>
<h1 id="documentation" class="section-header"><a href="#documentation">Documentation</a></h1>
<p>Rust doc can be found <a href="http://www.willusher.io/ispc-rs/ispc">here</a>, ISPC documentation can
be found <a href="https://ispc.github.io">here</a>.</p>
<h1 id="using-ispc-rs" class="section-header"><a href="#using-ispc-rs">Using ispc-rs</a></h1>
<p>With ispc-rs you can compile your ISPC code from your build script to
generate a native library and a Rust module containing bindings to
the exported ISPC functions. ispc-rs will output commands to Cargo to link
the native library, and you can import the Rust bindings into your code using
a provided macro to call into the library. Using ispc-rs in this mode
requires that the ISPC compiler and clang are available when compiling your
crate.</p>
<p>When writing a crate or program which wants to package and use ISPC
code, but not necessarily require these dependencies on the end user's system,
ispc-rs is actually split into two crates: a compile time crate (<code>ispc_compile</code>)
and a runtime crate (<code>ispc_rt</code>). The <code>ispc_compile</code> crate is used to compile
the ISPC code in a build script, generating the native library and Rust bindings.
The <code>ispc_rt</code> crate contains lightweight code to include in the build script
which will find and link against the previously compiled native libraries,
and a macro to import the previously generated Rust bindings. The recommended
use case is to include <code>ispc_compile</code> as an optional dependency behind a feature
gate. When building with this feature gate the ISPC code will be built, otherwise
the runtime crate will find and use the existing libraries.</p>
<h1 id="using-ispc-rs-as-a-single-crate" class="section-header"><a href="#using-ispc-rs-as-a-single-crate">Using ispc-rs as a Single Crate</a></h1>
<p>To use ispc-rs as a single crate, you'll want to add a build script to your
crate (<code>build.rs</code>), tell Cargo about it, and add ispc-rs as a build time and
compile time dependency</p>
<pre><code class="language-toml"># Cargo.toml
[package]
# ...
build = &quot;build.rs&quot;
 
[dependencies]
ispc = &quot;1.0.4&quot;
 
[build-dependencies]
ispc = &quot;1.0.4&quot;
</code></pre>
<p>Now you can use <code>ispc</code> to compile your code into a static library:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ispc</span>;
 
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Compile our ISPC library, this call will exit with EXIT_FAILURE if</span>
    <span class="comment">// compilation fails.</span>
    <span class="ident">ispc</span>::<span class="ident">compile_library</span>(<span class="string">&quot;simple&quot;</span>, <span class="kw-2">&amp;</span>[<span class="string">&quot;src/simple.ispc&quot;</span>]);
}</pre></div>
<p>Running <code>cargo build</code> should now build your ISPC files into a library and link your Rust
application with it. For extra convenience the <code>ispc_module</code> macro is provided to import
bindings to the library generated with <a href="https://github.com/crabtw/rust-bindgen">rust-bindgen</a>
into a module of the same name. Note that all the functions imported will be unsafe as they're
the raw C bindings to your lib.</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ispc</span>;
 
<span class="comment">// Functions exported from simple will be callable under simple::*</span>
<span class="macro">ispc_module</span><span class="macro">!</span>(<span class="ident">simple</span>);</pre></div>
<h2 id="requirements-for-compiling-ispc-code" class="section-header"><a href="#requirements-for-compiling-ispc-code">Requirements for Compiling ISPC Code</a></h2>
<p>Both the <a href="https://ispc.github.io/">ISPC compiler</a> and <a href="http://clang.llvm.org/">libclang</a>
(for <a href="https://github.com/crabtw/rust-bindgen">rust-bindgen</a>) must be available in your path
to compile the ISPC code and generate the bindings. These are not required if using <code>ispc_rt</code>
to link against a previously compiled library.</p>
<h3 id="windows-users" class="section-header"><a href="#windows-users">Windows Users</a></h3>
<p>You'll need Visual Studio and will have to use the MSVC ABI version of Rust since ISPC
and Clang link with MSVC on Windows. For bindgen to find libclang you'll need to copy
<code>libclang.lib</code> to <code>clang.lib</code> and place it in your path.</p>
<h1 id="using-the-separate-compile-and-runtime-crates" class="section-header"><a href="#using-the-separate-compile-and-runtime-crates">Using the Separate Compile and Runtime Crates</a></h1>
<p>The process of using the separate crates is similar to that of the single crate;
however, you'll use the individual <code>ispc_compile</code> and <code>ispc_rt</code> crates, with the
former marked as an optional dependency. This will allow end users to use the
crate and leverage its ISPC code, without needing to re-build the code on their
machine. For this reason, it's also recommended to build your ISPC code for multiple
vector ISAs, to allow for portability across CPU architectures. You'll also need
to package a compiled ISPC library for each host target triple. This can
be done by building your crate with the ispc feature enabled on each target
host system you want to support users of your library on. Note that users
of your crate on a system you haven't provided a binary for can still compile the ISPC
code themselves, by using your crate with the ispc feature enabled.</p>
<pre><code class="language-toml"># Cargo.toml
[package]
# ...
build = &quot;build.rs&quot;
 
[dependencies]
ispc_rt = &quot;1.0.2&quot;
 
[build-dependencies]
ispc_rt = &quot;1.0.2&quot;
ispc_compile = { &quot;1.0.4&quot;, optional = true }
 
[features]
ispc = [&quot;ispc_compile&quot;]
</code></pre>
<p>In the build script we can now use the <code>ispc</code> feature to optionally
compile the ispc code using <code>ispc_compile</code>, otherwise we'll link the
previously built code with <code>ispc_rt</code>. Here we'll also output the
compiled ISPC libraries and bindings into the src/ directory.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ispc_rt</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;ispc&quot;</span>)]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ispc_compile</span>;
 
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;ispc&quot;</span>)]</span>
<span class="kw">fn</span> <span class="ident">link_ispc</span>() {
    <span class="kw">use</span> <span class="ident">ispc_compile</span>::<span class="ident">TargetISA</span>;
    <span class="ident">ispc_compile</span>::<span class="ident">Config</span>::<span class="ident">new</span>()
        .<span class="ident">file</span>(<span class="string">&quot;src/simple.ispc&quot;</span>)
        .<span class="ident">target_isas</span>(<span class="macro">vec</span><span class="macro">!</span>[
            <span class="ident">TargetISA</span>::<span class="ident">SSE2i32x4</span>,
            <span class="ident">TargetISA</span>::<span class="ident">SSE4i32x4</span>,
            <span class="ident">TargetISA</span>::<span class="ident">AVX1i32x8</span>,
            <span class="ident">TargetISA</span>::<span class="ident">AVX2i32x8</span>,
            <span class="ident">TargetISA</span>::<span class="ident">AVX512KNLi32x16</span>,
            <span class="ident">TargetISA</span>::<span class="ident">AVX512SKXi32x16</span>])
        .<span class="ident">out_dir</span>(<span class="string">&quot;src/&quot;</span>)
        .<span class="ident">compile</span>(<span class="string">&quot;simple&quot;</span>);
}
 
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;ispc&quot;</span>))]</span>
<span class="kw">fn</span> <span class="ident">link_ispc</span>() {
    <span class="ident">ispc_rt</span>::<span class="ident">PackagedModule</span>::<span class="ident">new</span>(<span class="string">&quot;simple&quot;</span>)
        .<span class="ident">lib_path</span>(<span class="string">&quot;src/&quot;</span>)
        .<span class="ident">link</span>();
}
 
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">link_ispc</span>();
}</pre></div>
<p>Running <code>cargo build --features ispc</code> will now build your ISPC files into a library
and generate bindings for your exported ISPC functions. The compiled library and
generated bindings file will be saved under <code>src/</code>, to allow packaging with the rest
of the crate. When building with <code>cargo build</code>, the previously compiled library
for the host system will be linked against.</p>
<p>Whether building with or without the ispc feature, you can import the generated
bindings into your rust code with the <code>ispc_module!</code> macro as before:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">ispc</span>;
 
<span class="comment">// Functions exported from simple will be callable under simple::*</span>
<span class="macro">ispc_module</span><span class="macro">!</span>(<span class="ident">simple</span>);</pre></div>
<p>Some more complete examples can be found in the
<a href="https://github.com/Twinklebear/ispc-rs/tree/master/examples">examples/</a> folder.
The separate crates example is <a href="https://github.com/Twinklebear/ispc-rs/tree/master/examples/simple">here</a></p>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="exec/index.html" title='ispc::exec mod'>exec</a></td><td class='docblock-short'><p>Defines the trait that must be implemented by ISPC task execution systems
and provides a default threaded one for use.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="instrument/index.html" title='ispc::instrument mod'>instrument</a></td><td class='docblock-short'><p>Defines the trait that must be implemented by ISPC instrumentation callbacks structs
and provides a default one.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="opt/index.html" title='ispc::opt mod'>opt</a></td><td class='docblock-short'><p>This module has various option flags and configs we can pass to ISPC,
located here for convience and clutter reduction.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="task/index.html" title='ispc::task mod'>task</a></td><td class='docblock-short'><p>Defines structs for operating on ISPC task groups and getting chunks
of a task to be scheduled on to threads</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.ispc_module.html" title='ispc::ispc_module macro'>ispc_module</a></td><td class='docblock-short'><p>Convenience macro for generating the module to hold the raw/unsafe ISPC bindings.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.ispc_module.html" title='ispc::ispc_module macro'>ispc_module</a></td><td class='docblock-short'><p>Convenience macro for generating the module to hold the raw/unsafe ISPC bindings.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Config.html" title='ispc::Config struct'>Config</a></td><td class='docblock-short'><p>Extra configuration to be passed to ISPC</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.PackagedModule.html" title='ispc::PackagedModule struct'>PackagedModule</a></td><td class='docblock-short'><p>A <code>PackagedModule</code> refers to an ISPC module which was previously
built using <code>ispc_compile</code>, and is now distributed with
the crate.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.compile_library.html" title='ispc::compile_library fn'>compile_library</a></td><td class='docblock-short'><p>Compile the list of ISPC files into a static library and generate bindings
using bindgen. The library name should not contain a lib prefix or a lib
extension like '.a' or '.lib', the appropriate prefix and suffix will be
added based on the compilation target.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.print_instrumenting_summary.html" title='ispc::print_instrumenting_summary fn'>print_instrumenting_summary</a></td><td class='docblock-short'><p>Print out a summary of performace data gathered from instrumenting ISPC.
Must enable instrumenting to have this record and print data, see
<code>Config::instrument</code>.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.set_instrument.html" title='ispc::set_instrument fn'>set_instrument</a></td><td class='docblock-short'><p>If you have implemented your own instrument for logging ISPC performance
data you can use this function to provide it for use instead of the
default one. This function <strong>must</strong> be called before calling into ISPC code,
otherwise the instrumenter will already be set to the default.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.set_task_system.html" title='ispc::set_task_system fn'>set_task_system</a></td><td class='docblock-short'><p>If you have implemented your own task system you can provide it for use instead
of the default threaded one. This must be done prior to calling ISPC code which
spawns tasks otherwise the task system will have already been initialized to
<code>Parallel</code>, which you can also see as an example for implementing a task system.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "ispc";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>